# SPDX-License-Identifier: AGPL-3.0-or-later

import os
import re
import time
from decimal import Decimal
from io import SEEK_CUR, SEEK_SET
from pathlib import Path
from shutil import copy2
import sh

from SCons.Action import Action
from SCons.Builder import Builder
from SCons.Environment import Environment

from scripts.scons.utility import FindIndex, GlobRecursive, IsFileName

Import('stage1')
Import('stage2')
Import('kernel')

Import('TARGET_ENVIRONMENT')
TARGET_ENVIRONMENT: Environment
env:Environment = TARGET_ENVIRONMENT

SECTOR_SIZE = 512

def generate_image_file(target: str, size_sectors: int):
    with open(target, 'wb') as fout:
        fout.write(bytes(size_sectors * SECTOR_SIZE))
        fout.close()

def create_filesystem(target: str, filesystem, reserved_sectors=0, offset=0):
    if filesystem in ['fat12', 'fat16', 'fat32']:
        reserved_sectors += 1
        if filesystem == 'fat32':
            reserved_sectors += 1

        mkfs_fat = sh.Command('mkfs.fat')
        mkfs_fat(target,
                 F=filesystem[3:],            # fat size
                 n='VALKYRIE',                    # label
                 R=reserved_sectors,      # reserved sectors
                 offset=offset
        )
    elif filesystem == 'ext2':
        mkfs_ext2 = sh.Command('mkfs.ext2')
        mkfs_ext2(target,
                  L='VALKYRIE',                   # label
                  E=f'offset={offset * SECTOR_SIZE}'
        )
    else:
        raise ValueError('Unsupported filesystem ' + filesystem)


def find_symbol_in_map_file(map_file: str, symbol: str):
    with map_file.open('r') as fmap:
        for line in fmap:
            if symbol in line:
                match = re.search('0x([0-9a-fA-F]+)', line)
                if match is not None:
                    return int(match.group(1), base=16)
    return None


def install_stage1(target: str, stage1: str, stage2_offset, stage2_size, offset=0):
    # find stage1 map file
    map_file = Path(stage1).with_suffix('.map')
    if not map_file.exists():
        raise ValueError("Can't find " + map_file)
    
    entry_offset = find_symbol_in_map_file(map_file, '__entry_start')
    if entry_offset is None:
        raise ValueError("Can't find __entry_start symbol in map file " + str(map_file))
    entry_offset -= 0x7c00

    stage2_start = find_symbol_in_map_file(map_file, 'stage2_location')
    if stage2_start is None:
        raise ValueError("Can't find stage2_location symbol in map file " + str(map_file))
    stage2_start -= 0x7c00

    with open(stage1, 'rb') as fstage1:
        with os.fdopen(os.open(target, os.O_WRONLY | os.O_CREAT), 'wb+') as ftarget:
            ftarget.seek(offset * SECTOR_SIZE, SEEK_SET)

            # write first 3 bytes jump instruction
            ftarget.write(fstage1.read(3))

            # write starting at entry_offset (end of header)
            fstage1.seek(entry_offset - 3, SEEK_CUR)
            ftarget.seek(entry_offset - 3, SEEK_CUR)
            ftarget.write(fstage1.read())

            # write location of stage2
            ftarget.seek(offset * SECTOR_SIZE + stage2_start, SEEK_SET)
            ftarget.write(stage2_offset.to_bytes(4, byteorder='little'))
            ftarget.write(stage2_size.to_bytes(1, byteorder='little'))

def install_stage2(target: str, stage2: str, offset=0, limit=None):
    with open(stage2, 'rb') as fstage2:
        with os.fdopen(os.open(target, os.O_WRONLY | os.O_CREAT), 'wb+') as ftarget:
            ftarget.seek(offset * SECTOR_SIZE, SEEK_SET)
            ftarget.write(fstage2.read())

def build_floppy(image, stage1, stage2, kernel, kernel_modules, files, env):
    size_sectors = 2880
    stage2_size = os.stat(stage2).st_size
    stage2_sectors = (stage2_size + SECTOR_SIZE - 1) // SECTOR_SIZE
    
    generate_image_file(image, size_sectors)

    print(f"> formatting file using fat12...")
    create_filesystem(image, 'fat12', stage2_sectors)

    print(f"> installing stage1...")
    install_stage1(image, stage1, stage2_offset=1, stage2_size=stage2_sectors)

    print(f"> installing stage2...")
    install_stage2(image, stage2, offset=1)

    print(f"> copying files...")
    print('    ... copying', kernel)
    sh.mmd('-i', image, "::sys")
    sh.mcopy('-i', image, kernel, "::sys/")
    
    # Copy kernel modules (dynamic libraries)
    for module in kernel_modules:
        print('    ... copying', module)
        sh.mcopy('-i', image, module, "::sys/")

    # copy rest of files
    src_root = env['BASEDIR']
    for file in files:
        file_src = file.srcnode().path
        file_rel = os.path.relpath(file_src, src_root)
        file_dst = '::' + file_rel

        if os.path.isdir(file_src):
            print('    ... creating directory', file_rel)
            sh.mmd('-i', image, file_dst)
        else:
            print('    ... copying', file_rel)
            sh.mcopy('-i', image, file_src, file_dst)

    username=os.getlogin()
    print(f"> changing ownership of {image} to {os.getuid()}...")
    sh.sudo.chown(f'{username}:{username}', image)
    print(f"> changing all build files to owned by {os.getuid()}")
    sh.sudo.chown('-R', f'{username}:{username}', 'build/')

def create_partition_table(target: str, align_start: int, filesystem: str = 'fat32'):
    """Create MBR partition table with correct filesystem type.
    
    Uses parted CLI to ensure the partition type ID is set correctly.
    (python-parted defaults to 0x83 Linux, which mkfs.fat does not change.)
    """
    # Create msdos (MBR) label
    sh.parted('-s', target, 'mklabel', 'msdos')
    
    # Map filesystem type to parted filesystem name
    parted_fs = {
        'fat12': 'fat12',
        'fat16': 'fat16',
        'fat32': 'fat32',
        'ext2': 'ext2'
    }.get(filesystem, 'fat32')
    
    # Create partition starting at align_start and spanning to end of disk
    # parted's mkpart requires: <name> <type> <fs-type> <start> <end>
    sh.parted('-s', target, 'mkpart', 'primary', parted_fs, f'{align_start}s', '100%')
    
    # Set boot flag on partition 1
    sh.parted('-s', target, 'set', '1', 'boot', 'on')


def mount_fs(image: str, mount_dir: str):
    # Use losetup + mount instead of guestmount (avoids kernel read permission issues)
    import sh
    import time
    import subprocess
    
    print("    > associating image with a loop device...")
    device = sh.sudo.losetup('-fP', '--show', image).strip()
    
    # Wait for loop device to be set up and partitions to appear
    partition = f'{device}p1'
    max_retries = 10
    retry_count = 0
    while retry_count < max_retries:
        try:
            # Check if partition device exists
            result = subprocess.run(['ls', '-la', partition], capture_output=True, timeout=1)
            if result.returncode == 0:
                break
        except:
            pass
        time.sleep(0.5)
        retry_count += 1
    
    if retry_count >= max_retries:
        print(f"ERROR: Partition {partition} did not appear after losetup")
        # Try to list what loop devices we have
        subprocess.run(['losetup', '-l'], check=False)
        raise RuntimeError(f"Loop partition {partition} not found")
    
    # Store the device path BEFORE mounting (in the parent directory on the host FS)
    device_file = mount_dir + '.device'
    with open(device_file, 'w') as f:
        f.write(device)
    
    print(f"    > mounting {partition} to {mount_dir}...")
    sh.sudo.mount(partition, mount_dir)

def unmount_fs(mount_dir: str):
    import sh
    import time
    print("Waiting for disk to be clear...")
    time.sleep(2)
    
    # Read the device path from the host FS (not inside the mount)
    device_file = mount_dir + '.device'
    
    # Unmount the directory first. Requires root.
    sh.sudo.umount(mount_dir)
    
    # Read the loop device path we saved.
    with open(device_file, 'r') as f:
        device = f.read().strip()
        
    # Detach the loop device. Requires root.
    print(f"    > detaching loop device {device}...")
    sh.sudo.losetup('-d', device)
    
    # Clean up the device file
    os.remove(device_file)


def build_disk(image, stage1, stage2, kernel, kernel_modules, files, env):
    size_sectors = (env['imageSize'] + SECTOR_SIZE - 1) // SECTOR_SIZE
    file_system = env['imageFS']
    partition_offset = 2048
 
    stage1_size = os.stat(stage1).st_size
    stage2_size = os.stat(stage2).st_size
    stage2_sectors = (stage2_size + SECTOR_SIZE - 1) // SECTOR_SIZE

    generate_image_file(image, size_sectors)

    # create partition table
    print(f"> creating partition table...")
    create_partition_table(image, partition_offset)

    # create file system
    print(f"> formatting file using {file_system}...")
    create_filesystem(image, file_system, offset=partition_offset)

    # install stage1 at LBA 0 (MBR bootcode + BDB header)
    print(f"> installing stage1...")
    install_stage1(image, stage1, offset=partition_offset, stage2_offset=1, stage2_size=stage2_sectors)
 
    # install stage2 at LBA 1 (first-stage loader)
    print(f"> installing stage2...")
    install_stage2(image, stage2, offset=1, limit=partition_offset)

    # Create temp directory in the build folder (same directory as the image)
    tempdir = os.path.join(os.path.dirname(image), 'tmp_mount')
    try:
        # mount
        os.makedirs(tempdir, exist_ok=True)

        print(f"> mounting image to {tempdir}...")
        mount_fs(image, tempdir)

        # copy kernel
        print(f"> copying kernel...")
        bootdir = os.path.join(tempdir, 'sys')
        sh.sudo.mkdir('-p', bootdir)
        sh.sudo.cp(kernel, bootdir)
        
        # copy kernel modules (dynamic libraries)
        for module in kernel_modules:
            print(f"    ... copying {os.path.basename(module)}")
            sh.sudo.cp(module, bootdir)

        # copy rest of files
        src_root = env['BASEDIR']
        print(f"> copying files...")
        for file in files:
            file_src = file.srcnode().path
            file_rel = os.path.relpath(file_src, src_root)
            file_dst = os.path.join(tempdir, file_rel)

            if os.path.isdir(file_src):
                print('    ... creating directory', file_rel)
                sh.sudo.mkdir('-p', file_dst)
            else:
                print('    ... copying', file_rel)
                sh.sudo.cp(file_src, file_dst)

    finally:
        print("> cleaning up...")
        try:
            unmount_fs(tempdir)
            # Change ownership of temp directory back to the user before deleting
            # Remove the entire directory tree
            import shutil
            shutil.rmtree(tempdir)
        except Exception as e:
            print(f"Error during cleanup: {e}")
            raise
    
    # Change ownership of the final image file to the current user
    username=os.getlogin()
    print(f"> changing ownership of {image} to {os.getuid()}...")
    sh.sudo.chown(f'{username}:{username}', image)
    print(f"> changing all build files to owned by {os.getuid()}")
    sh.sudo.chown('-R', f'{username}:{username}', 'build/')


def build_image(target, source, env):
    stage1 = str(source[0])
    stage2 = str(source[1])
    # kernel is an array - first element is the main executable (core.elf)
    # Additional elements are module libraries
    kernel_exe = str(source[2])  # main kernel executable
    kernel_modules = [str(src) for src in source[3:] if 'kernel' in str(src)]
    files = [src for src in source[3:] if 'kernel' not in str(src)]

    image = str(target[0])
    if env['imageType'] == 'floppy':
        build_floppy(image, stage1, stage2, kernel_exe, kernel_modules, files, env)
    elif env['imageType'] == 'disk':
        build_disk(image, stage1, stage2, kernel_exe, kernel_modules, files, env)
    else:
        raise ValueError('Unknown image type ' + env['imageType'])


# Setup image target
root = env.Dir('root')
root_content = GlobRecursive(env, '*', root)
inputs = [stage1, stage2] + kernel + root_content

output_fmt = env["outputFormat"]
# if env['imageType'] == 'qcow3':
#     output_fmt = 'qcow3'

output = f'{env["outputFile"]}.{output_fmt}'

image = env.Command(output, inputs,
                    action=Action(build_image, 'Creating disk image...'), 
                    BASEDIR=root.srcnode().path)

Export('image')
