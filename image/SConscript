# SPDX-License-Identifier: AGPL-3.0-or-later

import os
import re
import time
from decimal import Decimal
from io import SEEK_CUR, SEEK_SET
from pathlib import Path
from shutil import copy2
import sh

from SCons.Action import Action
from SCons.Builder import Builder
from SCons.Environment import Environment
from SCons.Script import Flatten

from scripts.scons.utility import FindIndex, GlobRecursive, IsFileName

Import('core')
Import('kernel_libraries')

Import('TARGET_ENVIRONMENT')
TARGET_ENVIRONMENT: Environment
env:Environment = TARGET_ENVIRONMENT

SECTOR_SIZE = 512

def generate_image_file(target: str, size_sectors: int):
    with open(target, 'wb') as fout:
        fout.write(bytes(size_sectors * SECTOR_SIZE))
        fout.close()

def create_filesystem(target: str, filesystem, reserved_sectors=0, offset=0):
    if filesystem in ['fat12', 'fat16', 'fat32']:
        reserved_sectors += 1
        if filesystem == 'fat32':
            reserved_sectors += 1

        mkfs_fat = sh.Command('mkfs.fat')
        mkfs_fat(target,
                 F=filesystem[3:],            # fat size
                 n='VALKYRIE',                    # label
                 R=reserved_sectors,      # reserved sectors
                 offset=offset
        )
    elif filesystem == 'ext2':
        mkfs_ext2 = sh.Command('mkfs.ext2')
        mkfs_ext2(target,
                  L='VALKYRIE',                   # label
                  E=f'offset={offset * SECTOR_SIZE}'
        )
    else:
        raise ValueError('Unsupported filesystem ' + filesystem)


def find_symbol_in_map_file(map_file: str, symbol: str):
    with map_file.open('r') as fmap:
        for line in fmap:
            if symbol in line:
                match = re.search('0x([0-9a-fA-F]+)', line)
                if match is not None:
                    return int(match.group(1), base=16)
    return None


def install_grub(mount_dir: str):

    device_file = mount_dir + '.device'
    if not os.path.exists(device_file):
        raise RuntimeError(f"Device file {device_file} not found; cannot install GRUB")

    with open(device_file, 'r') as f:
        device = f.read().strip()

    bootdir = os.path.join(mount_dir, 'boot')
    sh.sudo.mkdir('-p', bootdir)

    print(f"    > installing GRUB on device {device} with boot-directory {bootdir}...")
    # Run grub-install against the loop device. Use i386-pc (BIOS) target for
    # the project's boot layout. --recheck forces probe of device.
    sh.sudo('grub-install', '--target=i386-pc', f'--boot-directory={bootdir}', '--recheck', device)

def create_partition_table(target: str, align_start: int, filesystem: str = 'fat32'):
    """Create MBR partition table with correct filesystem type.
    
    Uses parted CLI to ensure the partition type ID is set correctly.
    (python-parted defaults to 0x83 Linux, which mkfs.fat does not change.)
    """
    # Create msdos (MBR) label
    sh.parted('-s', target, 'mklabel', 'msdos')
    
    # Map filesystem type to parted filesystem name
    parted_fs = {
        'fat12': 'fat12',
        'fat16': 'fat16',
        'fat32': 'fat32',
        'ext2': 'ext2'
    }.get(filesystem, 'fat32')
    
    # Create partition starting at align_start and spanning to end of disk
    # parted's mkpart requires: <name> <type> <fs-type> <start> <end>
    sh.parted('-s', target, 'mkpart', 'primary', parted_fs, f'{align_start}s', '100%')
    
    # Set boot flag on partition 1
    sh.parted('-s', target, 'set', '1', 'boot', 'on')


def mount_fs(image: str, mount_dir: str):
    # Use losetup + mount instead of guestmount (avoids kernel read permission issues)
    import sh
    import time
    import subprocess
    
    print("    > associating image with a loop device...")
    device = sh.sudo.losetup('-fP', '--show', image).strip()
    
    # Wait for loop device to be set up and partitions to appear
    partition = f'{device}p1'
    max_retries = 10
    retry_count = 0
    while retry_count < max_retries:
        try:
            # Check if partition device exists
            result = subprocess.run(['ls', '-la', partition], capture_output=True, timeout=1)
            if result.returncode == 0:
                break
        except:
            pass
        time.sleep(0.5)
        retry_count += 1
    
    if retry_count >= max_retries:
        print(f"ERROR: Partition {partition} did not appear after losetup")
        # Try to list what loop devices we have
        subprocess.run(['losetup', '-l'], check=False)
        raise RuntimeError(f"Loop partition {partition} not found")
    
    # Store the device path BEFORE mounting (in the parent directory on the host FS)
    device_file = mount_dir + '.device'
    with open(device_file, 'w') as f:
        f.write(device)
    
    print(f"    > mounting {partition} to {mount_dir}...")
    sh.sudo.mount(partition, mount_dir)

def unmount_fs(mount_dir: str):
    import sh
    import time
    print("Waiting for disk to be clear...")
    time.sleep(2)
    
    # Read the device path from the host FS (not inside the mount)
    device_file = mount_dir + '.device'
    
    # Unmount the directory first. Requires root.
    sh.sudo.umount(mount_dir)
    
    # Read the loop device path we saved.
    with open(device_file, 'r') as f:
        device = f.read().strip()
        
    # Detach the loop device. Requires root.
    print(f"    > detaching loop device {device}...")
    sh.sudo.losetup('-d', device)
    
    # Clean up the device file
    os.remove(device_file)


def build_disk(image, core_exe, kernel_libraries, files, env):
    size_sectors = (env['imageSize'] + SECTOR_SIZE - 1) // SECTOR_SIZE
    file_system = env['imageFS']
    partition_offset = 2048

    generate_image_file(image, size_sectors)

    # create partition table
    print(f"> creating partition table...")
    create_partition_table(image, partition_offset)

    # create file system
    print(f"> formatting file using {file_system}...")
    create_filesystem(image, file_system, offset=partition_offset)

    # Create temp directory in the build folder (same directory as the image)
    tempdir = os.path.join(os.path.dirname(image), 'tmp_mount')
    try:
        # mount
        os.makedirs(tempdir, exist_ok=True)

        print(f"> mounting image to {tempdir}...")
        mount_fs(image, tempdir)

        # copy kernel core
        print(f"> copying kernel...")
        bootdir = os.path.join(tempdir, 'boot')
        sh.sudo.mkdir('-p', bootdir)
        sh.sudo.cp(core_exe, bootdir)
        
        # copy kernel libraries to /usr/lib
        libdir = os.path.join(tempdir, 'usr', 'lib')
        sh.sudo.mkdir('-p', libdir)
        for library in kernel_libraries:
            print(f"    ... copying {os.path.basename(library)} to /usr/lib")
            sh.sudo.cp(library, libdir)

        # copy rest of files
        src_root = env['BASEDIR']
        print(f"> copying files...")
        for file in files:
            file_src = file.srcnode().path
            file_rel = os.path.relpath(file_src, src_root)
            file_dst = os.path.join(tempdir, file_rel)

            if os.path.isdir(file_src):
                print('    ... creating directory', file_rel)
                sh.sudo.mkdir('-p', file_dst)
            else:
                print('    ... copying', file_rel)
                sh.sudo.cp(file_src, file_dst)

        install_grub(tempdir)

    finally:
        print("> cleaning up...")
        try:
            unmount_fs(tempdir)
            # Change ownership of temp directory back to the user before deleting
            # Remove the entire directory tree
            import shutil
            shutil.rmtree(tempdir)
        except Exception as e:
            print(f"Error during cleanup: {e}")
            raise
    
    # Change ownership of the final image file to the current user
    username=os.getlogin()
    print(f"> changing ownership of {image} to {username}...")
    sh.sudo.chown(f'{username}:{username}', image)
    print(f"> changing all build files to owned by {username}")
    sh.sudo.chown('-R', f'{username}:{username}', 'build/')


def build_image(target, source, env):
    # Source list may contain many nodes; try to reliably find the kernel ELF
    core_exe = None
    for src in source:
        p = str(src)
        # prefer ELF/binary kernel artifacts
        if p.endswith('.elf') or p.endswith('.bin') or p.endswith('.iso'):
            core_exe = p
            break
    # fallback: use first "core" named artifact or the imported `core` variable
    if core_exe is None:
        for src in source:
            p = os.path.basename(str(src))
            if 'core' in p or 'kernel' in p or 'valkyrie' in p:
                core_exe = str(src)
                break
    if core_exe is None:
        # last resort: try env provided path
        core_exe = env.get('CORE_EXE')
    if core_exe is None:
        raise RuntimeError("Core executable not found in build inputs")

    # Flatten the library list and normalize paths for copying
    lib_nodes = Flatten(kernel_libraries)
    libs = []
    lib_compare = set()
    for lib in lib_nodes:
        try:
            path = lib.get_abspath()
        except Exception:
            path = str(lib)
        libs.append(path)
        lib_compare.add(str(lib))

    files = [src for src in source if str(src) != core_exe and str(src) not in lib_compare]

    image = str(target[0])

    build_disk(image, core_exe, libs, files, env)
 
# Setup image target
root = env.Dir('root')
root_content = GlobRecursive(env, '*', root)
inputs = [core] + kernel_libraries + root_content

output_fmt = env["outputFormat"]

output = f'{env["outputFile"]}.{output_fmt}'

image = env.Command(output, inputs,
                    action=Action(build_image, 'Creating disk image...'), 
                    BASEDIR=root.srcnode().path)

Export('image')
