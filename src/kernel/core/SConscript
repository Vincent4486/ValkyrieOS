# SPDX-License-Identifier: AGPL-3.0-or-later

import os
import subprocess

from SCons.Environment import Environment
from SCons.Script import Dir
from scripts.scons.utility import GlobRecursive, FindIndex, IsFileName


Import('TARGET_ENVIRONMENT')
TARGET_ENVIRONMENT: Environment

env = TARGET_ENVIRONMENT.Clone()
# With variant_dir and duplicate=0, we need to explicitly reference the source files
# The build root is at '#' (where SConstruct is), so src/kernel/core is at src/kernel/core
src_dir = Dir('#src/kernel/core').abspath
# Node (relative) to pass into GlobRecursive so it searches the actual source
src_node = '#src/kernel/core'

env.Append(
    # Enable position-independent code for dynamic linking support
    # Build as a position-independent executable (PIE) so the linker
    # emits .dynsym/.rel.plt sections and generates PLT/GOT relocations.
    CCFLAGS = ['-fPIE'],
    LINKFLAGS = [
        '-Wl,-T', os.path.join(src_dir, 'linker.ld'),
        '-Wl,-Map=' + env.File('core.map').path,
        # Create relocation records for undefined symbols (GOT/PLT)
        # The linker will generate R_386_GLOB_DAT and R_386_JMP_SLOT relocations
        '-Wl,-z,notext',  # Allow relocations in text segment
        '-Wl,--unresolved-symbols=ignore-all',  # Allow undefined symbols - will be resolved at runtime
        '-pie',
        '-Wl,--as-needed',
        '-Wl,--export-dynamic',
    ],
    CPATH = [ src_dir, '#lib' ],
    CPPPATH = [ src_dir, '#lib' ],
    # Include source directory for assembly files (nasm -I flag for include paths)
    # Use list format so each item becomes a separate argument
    ASFLAGS = [ '-I', src_dir + '/', '-f', 'elf' ]
)

# Glob files directly from the source directory using os.walk
# This is necessary because we're in a variant_dir and GlobRecursive looks in the build dir
sources = []
for root, dirs, files in os.walk(src_dir):
    for file in files:
        full_path = os.path.join(root, file)
        if file.endswith(('.c', '.cpp', '.asm')):
            # Make path relative to src_dir so SCons puts objects in build dir
            rel_path = os.path.relpath(full_path, src_dir)
            # Use File() with the relative path - SCons will resolve it relative to variant_dir
            sources.append(rel_path)

# Compile Rust files. Handle SCons variable types
# (the config system may leave boolean-like values as strings).
rust_objects = []

# GlobRecursive must be pointed at the source directory when using variant_dir
rust_sources = GlobRecursive(env, '*.rs', src_node)
if rust_sources:
    def build_rust(target, source, env):
        # Use the original source file path (srcnode) so we compile the real source
        src = source[0].srcnode().path
        # Target is the build artifact path in the variant dir
        out = target[0].path
        out_obj = out

        # Determine optimization level
        opt_level = '0' if TARGET_ENVIRONMENT['config'] == 'debug' else '3'

        # Build rustc command directly (no rustup wrapper)
        rustc_cmd = env.get('RUSTC', 'rustc')
        cmd = [
            rustc_cmd,
            '--target', 'i686-unknown-linux-gnu',
            '-C', 'no-redzone=on',
            '-C', 'relocation-model=static',
            '-C', 'code-model=kernel',
            '-C', f'opt-level={opt_level}',
            '--edition', '2021',
            '--crate-type', 'lib',
            '-o', out_obj,
            src
        ]

        # Create environment for rustc with required variables
        rust_env = os.environ.copy()
        rust_env['HOME'] = '/home/vincent'
        rust_env['USER'] = 'vincent'
        result = subprocess.run(cmd, cwd=env.Dir('.').abspath, env=rust_env)
        if result.returncode != 0:
            return result.returncode
        return 0

    rust_builder = env.Builder(
        action=build_rust,
        suffix='.o',
        src_suffix='.rs',
        single_source=True
    )
    env.Append(BUILDERS={'RustObject': rust_builder})

    for src in rust_sources:
        obj = env.RustObject(src)
        rust_objects.append(obj)

objects = env.Object(sources) + rust_objects
obj_crti = objects.pop(FindIndex(objects, lambda item: IsFileName(item, 'crti.o')))
obj_crtn = objects.pop(FindIndex(objects, lambda item: IsFileName(item, 'crtn.o')))

objects = [
    obj_crti,
    os.path.join(env["TOOLCHAIN_LIBGCC"], 'crtbegin.o'),
    *objects,
    os.path.join(env["TOOLCHAIN_LIBGCC"], 'crtend.o'),
    obj_crtn
]

core = env.Program('core.elf', objects)

Export('core')
